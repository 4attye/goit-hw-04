Результат виконання коду:

    Size: 100
    Insertion Sort: 0.00010 seconds
    Merge Sort: 0.00007 seconds
    Timsort: 0.00001 seconds
  
    Size: 10000
    Insertion Sort: 1.12079 seconds
    Merge Sort: 0.01181 seconds
    Timsort: 0.00085 seconds
  
    Size: 50000
    Insertion Sort: 28.79178 seconds
    Merge Sort: 0.07122 seconds
    Timsort: 0.00500 seconds

Висновок:

      Проведене емпіричне тестування трьох алгоритмів сортування — сортування вставками, сортування злиттям та Timsort (вбудоване сортування Python) — підтверджує теоретичні оцінки складності й демонструє суттєві відмінності в ефективності:
      
          Сортування вставками (Insertion Sort) — показує найгірші результати при збільшенні розміру масиву. Через квадратичну складність O(n²) час виконання зростає дуже швидко. Якщо для 100 елементів час майже непомітний (0.0001 сек), то для 50 000 — майже 29 секунд, що робить цей алгоритм непридатним для великих обсягів даних.
          
          Сортування злиттям (Merge Sort) — значно ефективніше, особливо на більших масивах. Його складність O(n log n) забезпечує стабільне й швидке виконання, навіть при обробці 50 000 елементів — лише ~0.07 секунди. Однак у порівнянні з Timsort все ще поступається за швидкістю.
          
          Timsort — вбудований в Python алгоритм, поєднує переваги сортування вставками для малих підмасивів і сортування злиттям для загальної структури. Саме це робить його найшвидшим у всіх тестах:
          
            Для 100 елементів — 0.00001 сек
            Для 10 000 елементів — 0.00085 сек
            Для 50 000 елементів — 0.00500 сек
    
      Вбудоване сортування Python значно ефективніше завдяки використанню Timsort — гібридного алгоритму, що адаптується до структури даних. Це робить його оптимальним вибором для більшості завдань на практиці.
